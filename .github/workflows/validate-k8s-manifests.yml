# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

# Reusable workflow to render helm charts and validate their manifests using kubeconform
# A comment is made on the pull request containing the output

name: render helm charts and validate k8s manifests
on:
  workflow_call:
    inputs:
      strict:
        required: false
        description: "Run kubeconform with strict validation"
        default: false
        type: boolean

env:
  HEAD_REF: ${{ github.head_ref }}
  KUBECONFORM_VERSION: "0.7.0"
  KUBECONFORM_SHA256: "c31518ddd122663b3f3aa874cfe8178cb0988de944f29c74a0b9260920d115d3"
  KUBECONFORM_BASE_URL: "https://github.com/yannh/kubeconform/releases/download"
  KUBECONFORM_SCHEMA_LOCATION: "https://raw.githubusercontent.com/datreeio/CRDs-catalog/main/{{.Group}}/{{.ResourceKind}}_{{.ResourceAPIVersion}}.json"
  KUBECONFORM_CUSTOM_SCHEMA_LOCATION: "https://raw.githubusercontent.com/mozilla/mozcloud/main/crdSchemas/{{.Group}}/{{.ResourceKind}}_{{.ResourceAPIVersion}}.json"

jobs:
  get_changed_helm_charts:
    runs-on: ubuntu-latest
    outputs:
      matrix_charts: ${{ steps.find_changed_charts.outputs.matrix_changed_charts }}
      charts: ${{ steps.find_changed_charts.outputs.changed_charts }}
    steps:
      - name: checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 #v6.0.1
        with:
         fetch-depth: '100'
         persist-credentials: true # We are using these credentials in later steps

      - name: find changed helm charts
        id: find_changed_charts
        run: |
          git fetch origin $GITHUB_BASE_REF:$GITHUB_BASE_REF
          echo matrix_changed_charts=$(git diff --name-only $GITHUB_BASE_REF...HEAD -- '**/k8s/**/*.yaml' '**/k8s/**/*.yml' '**/k8s/**/*.tpl' '**/k8s/**/*.tmpl' | cut -d'/' -f1,2,3 | uniq | jq -R 'split("\n")' | jq -s 'flatten(1)') >> $GITHUB_OUTPUT
          echo changed_charts=$(git diff --name-only $GITHUB_BASE_REF...HEAD -- '**/k8s/**/*.yaml' '**/k8s/**/*.yml' '**/k8s/**/*.tpl' '**/k8s/**/*.tmpl' | cut -d'/' -f1,2,3 | uniq) >> $GITHUB_OUTPUT
        env:
          GITHUB_BASE_REF: ${{ github.base_ref }}

  render_head_ref_charts:
    runs-on: ubuntu-latest
    needs: get_changed_helm_charts
    strategy:
      matrix:
        chart: ${{ fromJSON(needs.get_changed_helm_charts.outputs.matrix_charts) }}
    steps:
      - name: checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 #v6.0.1
        with:
         persist-credentials: true # We are using these credentials in later steps

      - name: setup helm
        uses: azure/setup-helm@29960d0f5f19214b88e1d9ba750a9914ab0f1a2f #v4.0.0

      - name: render ${{ matrix.chart }} from head ref
        id: render_head
        run: |
          mkdir -p shared/head-charts
          git fetch origin "$HEAD_REF"
          git checkout  "$HEAD_REF" --
          if [ -f "$MATRIX_CHART/Chart.yaml" ]; then
            helm dependency update "$MATRIX_CHART"

            while read values_file; do
              filename=$(basename "${values_file}")
              filename_without_suffix=${filename%.*}

              env=${filename_without_suffix%*.values}
              env=${env#values-*}

              helm template $(basename -a "$MATRIX_CHART" ) "$MATRIX_CHART" \
                -f $values_file \
                --output-dir shared/charts/$MATRIX_CHART/$filename_without_suffix

              while read region_values_file; do
                region_filename=$(basename $region_values_file)
                region_filename_without_suffix=${region_filename%.*}

                helm template $(basename -a "$MATRIX_CHART") "$MATRIX_CHART" \
                  -f $values_file \
                  -f $region_values_file \
                  --output-dir shared/charts/$MATRIX_CHART/$region_filename_without_suffix

              done < <(find "$BASE_DIR/$MATRIX_CHART" \
                -maxdepth 1 \
                -type f \
                -regextype egrep \
                -regex ".*/values-${env}(-[[:alnum:]]+){2}\.(yaml|yml)$")
            done < <(find "$BASE_DIR/$MATRIX_CHART" \
              -maxdepth 1 \
              -type f \
              -regextype egrep \
              -regex ".*/([[:alnum:]]+\.)?values((-ent)?-([[:alnum:]]+))?\.(yaml|yml)$" \
              -not -regex ".*/values.(yaml|yml)$")
          fi
          echo sanitized_name=$(echo "$MATRIX_CHART" | sed 's/\//-/g') >> $GITHUB_OUTPUT
        env:
          MATRIX_CHART: ${{ matrix.chart }}

      - name: upload artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f #v6.0.0
        with:
          name: "k8s-manifests-${{ steps.render_head.outputs.sanitized_name }}"
          path: "shared"

  validate_rendered_helm_chart_manifests:
    runs-on: ubuntu-latest
    needs:
      - get_changed_helm_charts
      - render_head_ref_charts
    steps:
      - name: install kubeconform
        run: |
          set -euo pipefail

          FILENAME="kubeconform-linux-amd64.tar.gz"
          DOWNLOAD_URL="${KUBECONFORM_BASE_URL}/v${KUBECONFORM_VERSION}/${FILENAME}"

          echo "Downloading kubeconform from ${DOWNLOAD_URL}..."
          wget -q "$DOWNLOAD_URL" -O "$FILENAME"

          echo "${KUBECONFORM_SHA256}  $FILENAME" | sha256sum -c -

          echo "Extracting kubeconform..."
          tar -xzf "$FILENAME"
          chmod +x kubeconform
          sudo mv kubeconform /usr/local/bin/kubeconform

      - name: download artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 #v7.0.0
        with:
          pattern: k8s-manifests-*
          merge-multiple: true
          path: "shared"

      - name: validate k8s manifests
        id: validate_k8s_manifests
        env:
          STRICT: ${{ inputs.strict }}
          CHARTS: ${{ needs.get_changed_helm_charts.outputs.charts }}
        run: |
          set -euo pipefail

          # Optional strict flag
          STRICT_FLAG=""
          if [ "${STRICT}" = "true" ]; then
            STRICT_FLAG="-strict"
          fi
          # To support multi-chart tenants we need to normalize the kubeconform output
          # We are populating it with the standard kubeconform structure, but will append to these values during subsequent runs
          echo '{"summary":{"valid":0,"invalid":0,"errors":0,"skipped":0},"resources":[]}' > kubeconform.json
          exit_code=0

          for chart in $CHARTS; do
            echo "Validating ${chart}..."

            if [ -d "shared/charts/${chart}" ]; then
              tmp_output=$(mktemp)

              # Always run kubeconform and capture output, even if it fails
              /usr/local/bin/kubeconform \
                ${STRICT_FLAG} \
                -schema-location default \
                -schema-location "${KUBECONFORM_SCHEMA_LOCATION}" \
                -schema-location "${KUBECONFORM_CUSTOM_SCHEMA_LOCATION}" \
                -summary \
                -skip CustomResourceDefinition \
                -output json \
                "shared/charts/${chart}" > "$tmp_output" 2>&1 || exit_code=1

              # Merge output only if it's valid JSON
              if jq empty "$tmp_output" >/dev/null 2>&1; then
                jq --arg chartDir "shared/charts/${chart}/" \
                   --slurpfile base kubeconform.json \
                   '
                   {
                     summary: {
                       valid: ($base[0].summary.valid + .summary.valid),
                       invalid: ($base[0].summary.invalid + .summary.invalid),
                       errors: ($base[0].summary.errors + .summary.errors),
                       skipped: ($base[0].summary.skipped + .summary.skipped)
                     },
                     resources: ($base[0].resources + (.resources | map(.filename |= sub("^" + $chartDir; ""))))
                   }
                   ' "$tmp_output" > kubeconform.tmp && mv kubeconform.tmp kubeconform.json
              else
                echo "Warning: kubeconform output for ${chart} is not valid JSON:"
                cat "$tmp_output"
                exit_code=1
              fi
            else
              echo "Warning: Rendered output for ${chart} not found."
            fi
          done

          echo "kubeconform_exit_code=$exit_code" >> $GITHUB_OUTPUT

      - name: minimize previous kubeconform comments
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const marker = "<!-- kubeconform-marker -->";

            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            for (const comment of comments) {
              if (
                comment.body.includes(marker) &&
                comment.user.type === "Bot"
              ) {
                await github.graphql(`
                  mutation MinimizeComment($subjectId: ID!) {
                    minimizeComment(input: {
                      subjectId: $subjectId,
                      classifier: OUTDATED
                    }) {
                      minimizedComment {
                        isMinimized
                      }
                    }
                  }
                `, {
                  subjectId: comment.node_id
                });
              }
            }

      - name: post kubeconform comment
        if: steps.validate_k8s_manifests.outputs.kubeconform_exit_code != '0'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const fs = require('fs');

            const json = JSON.parse(fs.readFileSync('kubeconform.json', 'utf8'));

            const marker = '<!-- kubeconform-marker -->';
            const commentCharLimit = 65536;

            // Format the summary line
            const { valid, invalid, errors, skipped } = json.summary;
            const summaryLine = `Kubernetes Manifest Validation: ${valid + invalid + errors + skipped} resources found - Valid: ${valid}, Invalid: ${invalid}, Errors: ${errors}, Skipped: ${skipped}`;

            const errorDetails = json.resources.map(r => {
              return `${r.filename} - ${r.kind} ${r.name} failed validation: ${r.msg}`;
            }).join('\n');

            const sepEnd = "\n```\n</details>\n\nNote: Continued in next comment.";
            const sepStart = "Continued from previous comment:\n<details><summary>Show full output</summary>\n\n```text\n";
            const comStart = `${summaryLine}\n\n<details><summary>Show full output</summary>\n\n\`\`\`text\n`;

            function splitComment(content, maxSize, sepEnd, sepStart, comStart) {
              // Adapted from Atlantis SplitComment function
              // https://github.com/runatlantis/atlantis/blob/main/server/events/vcs/common/common.go#L18
              if (content.length <= (maxSize - comStart.length)) {
                return [`${comStart}${content}\n\`\`\`\n</details>\n${marker}`];
              }

              const maxWithSep = maxSize - sepEnd.length - sepStart.length;
              const numComments = Math.ceil(content.length / maxWithSep);
              const comments = [];

              for (let i = 0; i < numComments; i++) {
                const start = i * maxWithSep;
                const end = Math.min(content.length, (i + 1) * maxWithSep);
                let chunk = content.slice(start, end);

                if (i < numComments - 1) chunk += sepEnd;
                if (i > 0) chunk = sepStart + chunk;
                else chunk = comStart + chunk;

                comments.push(`${chunk}\n\`\`\`\n</details>\n${marker}`);
              }

              return comments;
            }

            const comments = splitComment(errorDetails, commentCharLimit, sepEnd, sepStart, comStart);

            for (const body of comments) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body
              });
            }

      - name: fail workflow if kubeconform validation fails
        run: |
          # We want this workflow to fail if kubeconform validation fails, but after posting the comment
          exit ${EXIT_CODE}
        env:
          EXIT_CODE: ${{ steps.validate_k8s_manifests.outputs.kubeconform_exit_code }}
